\addtocontents{xms}{\protect\addvspace{10pt}}
\chapter{Exemples Resolts amb Python}\label{chap:python-exemples}


\section{Exemples del cap√≠tol \ref*{ch:fonaments}}

\hypertarget{exemple:MillmanBateries}{\subsection{Exemple \ref*{ex:MillmanBateries} \MillmanBateries}}

En el llistat \vref{lst:MillmanBateries} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:MillmanBateries}. La resoluci√≥ es fa de dues maneres: utilitzant primer la funci√≥ \texttt{millman} del m√≤dul \texttt{qed.eng\_elec}, i fent servir despr√©s les classes \texttt{Network}, \texttt{VoltageSource} i \texttt{Impedance}  del mateix m√≤dul.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:MillmanBateries} \MillmanBateries},label=lst:MillmanBateries]{Python/Exemple-1-1.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}
Teorema de Millman
------------------
Z_Th = 11.3270 mŒ©
E_Th = 125.0562 V
Y_No = 88.28 S
J_No = 11.04 kA
I_Q  = 2.5006 A
U_Q  = 125.03 V

M√®tode dels nusos
------------------
Z_Th = 11.3270 mŒ©
E_Th = 125.0562 V
Y_No = 88.28 S
J_No = 11.04 kA
I_Q  = 2.5006 A
U_Q  = 125.03 V
\end{lstlisting} 


\hypertarget{exemple:MillmanTrifNeutre}{\subsection{Exemple \ref*{ex:MillmanTrifNeutre} \MillmanTrifNeutre}}

En el llistat \vref{lst:MillmanTrifNeutre} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:MillmanTrifNeutre}. La resoluci√≥ es fa de dues maneres: usant primer la funci√≥ \texttt{millman} del m√≤dul \texttt{qed.eng\_elec}, i fent servir despr√©s les classes \texttt{Network}, \texttt{VoltageSource} i \texttt{Impedance}  del mateix m√≤dul. Es fa servir tamb√© la classe \texttt{ComplexD} del m√≤dul \texttt{qed.utils}.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:MillmanTrifNeutre} \MillmanTrifNeutre},label=lst:MillmanTrifNeutre]{Python/Exemple-1-2.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}
Teorema de Millman
------------------------------
U_GN = 33.3433‚à†13.17¬∞ V
I_A  = 3953.6056‚à†-2.20¬∞ A
I_B  = 3174.7573‚à†-125.49¬∞ A
I_C  = 3453.8265‚à†127.59¬∞ A
I_N  = 0.7249‚à†13.17¬∞ A

M√®tode dels nusos
------------------------------
U_GN = 33.3433‚à†13.17¬∞ V
I_A  = 3953.6056‚à†-2.20¬∞ A
I_B  = 3174.7573‚à†-125.49¬∞ A
I_C  = 3453.8265‚à†127.59¬∞ A
I_N  = 0.7249‚à†13.17¬∞ A
\end{lstlisting} 


\hypertarget{exemple:Superposicio}{\subsection{Exemple \ref*{ex:Superposicio} \Superposicio}}

En el llistat \vref{lst:Superposicio} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:Superposicio}. La resoluci√≥ es fa amb les classes \texttt{Network}, \texttt{VoltageSource}, \texttt{CurrentSourceIdeal} i \texttt{Impedance} del m√≤dul \texttt{qed.eng\_elec}. Es fa servir tamb√© la classe \texttt{ComplexD} del m√≤dul \texttt{qed.utils}.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:Superposicio} \Superposicio},label=lst:Superposicio]{Python/Exemple-1-4.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}
Corrent pel condensador: 2.907‚à†26.57¬∞ A
\end{lstlisting} 


\hypertarget{exemple:CarDescRL}{\subsection{Exemple \ref*{ex:CarDescRL} \CarDescRL}}

En el llistat \vref{lst:CarDescRL} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:CarDescRL}. La resoluci√≥ es fa utilitzant funcions del m√≤dul num√®ric \texttt{numpy} i del m√≤dul gr√†fic  \texttt{matplotlib}.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:CarDescRL} \CarDescRL},label=lst:CarDescRL]{Python/Exemple-1-8.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}[mathescape=true]
	
$ \includegraphics{Cap-PythonExemp-CarDescRL.pdf} $
\end{lstlisting}


\hypertarget{exemple:CurtcircuitRL}{\subsection{Exemple \ref*{ex:CurtcircuitRL} \CurtcircuitRL}}
En el llistat \vref{lst:CurtcircuitRL} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:CurtcircuitRL}. La resoluci√≥ es fa utilitzant funcions del m√≤dul num√®ric \texttt{numpy} i del m√≤dul gr√†fic  \texttt{matplotlib}.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:CurtcircuitRL} \CurtcircuitRL},label=lst:CurtcircuitRL]{Python/Exemple-1-9.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}

\begin{lstlisting}[mathescape=true]
	
Intensitat sim√®trica efica√ß = 25423.0955 A

Intensitat asim√®trica de pic = 71.9 kA

Intensitat asim√®trica efica√ß = 44.0 kA








$ \includegraphics{Cap-PythonExemp-CurtcircuitRL.pdf} $
\end{lstlisting}


\hypertarget{exemple:CurtcircuitPicRL}{\subsection{Exemple \ref*{ex:CurtcircuitPicRL} \CurtcircuitPicRL}}
En el llistat \vref{lst:CurtcircuitPicRL} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:CurtcircuitPicRL}. La resoluci√≥ es fa utilitzant funcions del m√≤dul num√®ric \texttt{numpy}, i la funci√≥ \texttt{minimize\_scalar} del m√≤dul  \texttt{scipy.optimize}, la qual troba m√≠nims locals d'una funci√≥; com que en aquest cas  el que es vol trobar √©s un m√†xim local, cal posar un signe negatiu davant de la funci√≥ que es passa a \texttt{minimize\_scalar} i un signe negatiu davant de la soluci√≥ obtinguda.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:CurtcircuitPicRL} \CurtcircuitPicRL},label=lst:CurtcircuitPicRL]{Python/Exemple-1-10.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}
Factor Œ∫ (CEI 60909-1) = 1.8452
Intensitat asim√®trica de pic (CEI 60909-1) = 66.3 kA
Intensitat asim√®trica de pic (exacta) = 66075.5 A (t = 9.6650 ms)
\end{lstlisting}


\hypertarget{exemple:Malles}{\subsection{Exemple \ref*{ex:Malles} \Malles}}
En el llistat \vref{lst:Malles} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:Malles}. La resoluci√≥ es fa de dues maneres: utilitzant primer la funci√≥ \texttt{solve} del m√≤dul \texttt{scipy.linalg}, i fent servir despr√©s les classes \texttt{Network}, \texttt{VoltageSource} i \texttt{Impedance} del m√≤dul \texttt{qed.eng\_elc}.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:Malles} \Malles},label=lst:Malles]{Python/Exemple-1-11.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}
Resoluci√≥ algebraica
--------------------
I1 = 2.75 A
I2 = -0.50 A
I3 = 2.25 A
I4 = 0.50 A
I5 = 1.25 A
I6 = 0.75 A

M√®tode dels nusos
-----------------
I1 = 2.75 A
I2 = -0.50 A
I3 = 2.25 A
I4 = 0.50 A
I5 = 1.25 A
I6 = 0.75 A
\end{lstlisting} 



\section{Exemples del cap√≠tol \ref*{sec:ch-calc-bas}}

\hypertarget{exemple:TriangleEstrella}{\subsection{Exemple \ref*{ex:TriangleEstrella} \TriangleEstrella}}
En el llistat \vref{lst:TriangleEstrella} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:TriangleEstrella}. Es fa servir la funci√≥ \texttt{D\_to\_Y} del m√≤dul \texttt{qed.eng\_elec} per fer la transformaci√≥ de triangle a estrella.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:TriangleEstrella} \TriangleEstrella},label=lst:TriangleEstrella]{Python/Exemple-2-2.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}
Z_A = (4-2j) Œ©
Z_B = (4-2j) Œ©
Z_C = (-2-4j) Œ©
\end{lstlisting}


\hypertarget{exemple:ResCircPotAbs}{\subsection{Exemple \ref*{ex:ResCircPotAbs} \ResCircPotAbs}}
En el llistat \vref{lst:ResCircPotAbs} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:ResCircPotAbs}. Es fa servir la funci√≥ \texttt{ezs\_u} del m√≤dul \texttt{qed.eng\_elec} per calcular la tensi√≥ de la c√†rrega.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:ResCircPotAbs} \ResCircPotAbs},label=lst:ResCircPotAbs]{Python/Exemple-2-3.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}
U   = 0.3165+0.0874j
I   = 2.1259-0.8346j
Z_S = 0.1150+0.0863j
\end{lstlisting}

Es pot observar que algun dels valors obtinguts no √©s exactament igual al valor obtingut en la resoluci√≥ manual; la difer√®ncia es deu al fet que en la resoluci√≥ manual s'han utilitzat nom√©s quatre xifres decimals, mentre que el programa treballa sempre amb tota la precisi√≥ de les variables (t√≠picament, setze xifres decimals).



\section{Exemples del cap√≠tol \ref*{sec:ch-comp-sim}}

\hypertarget{exemple:ImpedEquil}{\subsection{Exemple \ref*{ex:ImpedEquil} \ImpedEquil}}
En el llistat \vref{lst:ImpedEquil} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:ImpedEquil}. S'usen funcions relatives a les components sim√®triques del m√≤dul \texttt{qed.eng\_elec} per fer els c√†lculs. Es fa servir tamb√© la classe \texttt{ComplexD} del m√≤dul \texttt{qed.utils}.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:ImpedEquil} \ImpedEquil},label=lst:ImpedEquil]{Python/Exemple-3-1.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}
U_AB = 2760.00‚à†0.00¬∞ V
U_BC = 1840.00‚à†-124.23¬∞ V
U_CA = 2300.00‚à†138.59¬∞ V

U_AB_1 = 2267.09‚à†5.04¬∞ V
U_AB_2 = 539.77‚à†-21.66¬∞ V
U_AB_0 = 0.00‚à†153.43¬∞ V

U_AG_1 = 1308.91‚à†-24.96¬∞ V
U_AG_2 = 311.64‚à†8.34¬∞ V
U_AG_0 = 0.00‚à†0.00¬∞ V

I_A_1 = 130.89‚à†-24.96¬∞ A
I_A_2 = 31.16‚à†8.34¬∞ A
I_A_0 = 0.00‚à†0.00¬∞ A

S_3F = 543.11+0.00j kVA

U_AG = 1578.66‚à†-18.74¬∞ V
U_BG = 1362.86‚à†-158.16¬∞ V
U_CG = 1039.96‚à†102.78¬∞ V

U_AG = 1578.66‚à†-18.74¬∞ V
U_BG = 1362.86‚à†-158.16¬∞ V
U_CG = 1039.96‚à†102.78¬∞ V
\end{lstlisting}


\hypertarget{exemple:ImpedDesequil}{\subsection{Exemple \ref*{ex:ImpedDesequil} \ImpedDesequil}}
En el llistat \vref{lst:ImpedDesequil} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:ImpedDesequil}. S'usen funcions relatives a les components sim√®triques del m√≤dul \texttt{qed.eng\_elec} per fer els c√†lculs. Es fa servir tamb√© la classe \texttt{ComplexD} del m√≤dul \texttt{qed.utils}.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:ImpedDesequil} \ImpedDesequil},label=lst:ImpedDesequil]{Python/Exemple-3-2.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}
U_AB = 2760.00‚à†0.00¬∞ V
U_BC = 1840.00‚à†-124.23¬∞ V
U_CA = 2300.00‚à†138.59¬∞ V

U_AN = 1101.65‚à†-14.54¬∞ V
U_BN = 1716.07‚à†-170.72¬∞ V
U_CN = 1408.22‚à†117.89¬∞ V

U_AN_1 = 1308.91‚à†-24.96¬∞ V
U_AN_2 = 311.64‚à†8.34¬∞ V
U_AN_0 = 486.68‚à†151.73¬∞ V

U_GN = 486.68‚à†151.73¬∞ V
\end{lstlisting}




\section{Exemples del cap√≠tol \ref*{sec:ch-series-fourier}}

\hypertarget{exemple:CircuitFourier}{\subsection{Exemple \ref*{ex:CircuitFourier} \CircuitFourier}}
En el llistat \vref{lst:CircuitFourier} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:CircuitFourier}. La resoluci√≥ es fa usant funcions del m√≤dul num√®ric \texttt{numpy} i del m√≤dul gr√†fic  \texttt{matplotlib}.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:CircuitFourier} \CircuitFourier},label=lst:CircuitFourier]{Python/Exemple-4-3.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}[mathescape=true]
	
I = 0.5505 A
P = 3.03 W
P = 3.03 W







$ \includegraphics{Cap-PythonExemp-CircuitFourier-1.pdf} $





$ \includegraphics{Cap-PythonExemp-CircuitFourier-2.pdf} $
$ \includegraphics{Cap-PythonExemp-CircuitFourier-3.pdf} $
\end{lstlisting} 

L'√∫ltima gr√†fica √©s una ampliaci√≥ respecte de l'exemple resolt a m√†. S'utilitzen les funcions \texttt{fft.rfft} i \texttt{fft.rfftfreq} del m√≤dul num√®ric \texttt{numpy} per aplicar la transformada r√†pida de Fourier a l'ona rectangular de tensi√≥. El que s'obt√© correspon a la s√®rie de Fourier d'aquesta ona calculada en l'exemple resolt a  m√†, √©s a dir, termes de freq√º√®ncia \qty{100}{Hz}, \qty{300}{Hz}, \qty{500}{Hz}, etc., d'una amplitud respectiva de \qty{25,4648}{V}, \qty{8,4883}{V}, \qty{5,0292}{V}, etc. L'√∫s d'aquestes dues funcions no √©s senzill, i cal llegir amb atenci√≥ la documentaci√≥ del m√≤dul \texttt{numpy}; en particular, cal tenir en compte que per obtenir valors correctes s'ha utilitzat un m√∫ltiple enter del per√≠ode (\qty{40}{ms} en aquest cas) de l'ona.


\section{Exemples del cap√≠tol \ref*{sec:ch-laplace}}

\hypertarget{exemple:CircuitLaplace}{\subsection{Exemple \ref*{ex:CircuitLaplace} \CircuitLaplace}}
En el llistat \vref{lst:CircuitLaplace} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:CircuitLaplace}. La resoluci√≥ es fa fent √∫s de funcions del m√≤dul de matem√†tica simb√≤lica \texttt{sympy}, del m√≤dul num√®ric \texttt{numpy} i del m√≤dul gr√†fic  \texttt{matplotlib}. Del m√≤dul \texttt{sympy} es fa servir b√†sicament la funci√≥ \texttt{Eq} per definir equacions,  la funci√≥ \texttt{solve} per a√Øllar una variable d'una equaci√≥, la funci√≥ \texttt{subs} per substituir  una variable per la seva expressi√≥ en una equaci√≥, i la   funci√≥ \texttt{inverse\_laplace\_transform} per obtenir la transformada inversa de Laplace. Aquesta  darrera funci√≥ requereix que els valors num√®rics implicats siguin exactes i √©s per aix√≤ que cal fer servir la funci√≥ \texttt{Rational} quan tenim valors no enters; per exemple, en lloc de \texttt{L = 250e-3} cal utilitzar \texttt{sympy.Rational(250, 1000)}, i el lloc de \texttt{iL\_0 =  U\_bat/(R\_bat + R\_3)} cal utilitzar \texttt{iL\_0 = sympy.Rational(U\_bat, R\_bat + R\_3)}.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:CircuitLaplace} \CircuitLaplace},label=lst:CircuitLaplace]{Python/Exemple-5-3.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}[mathescape=true]
iL_0 = 4 A
uC_0 = 100 V
iL(s) = 4*(s + 1075)/(s**2 + 1475*s + 700000)
iL(t) = 4*(3*sqrt(111)*sin(75*sqrt(111)*t/2) + 37*cos(75*sqrt(111)*t/2))*exp(-1475*t/2)/37
iL(0) = 4 A


$ \includegraphics{Cap-PythonExemp-CircuitLaplace.pdf} $
\end{lstlisting} 



\hypertarget{exemple:CircuitLaplaceNul}{\subsection{Exemple \ref*{ex:CircuitLaplaceNul} \CircuitLaplaceNul}}

En el llistat \vref{lst:CircuitLaplaceNul} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:CircuitLaplaceNul}. La resoluci√≥ es fa emprant funcions del m√≤dul de matem√†tica simb√≤lica \texttt{sympy}, del m√≤dul num√®ric \texttt{numpy} i del m√≤dul gr√†fic  \texttt{matplotlib}. 
En aquest exemple no es pot seguir la metodologia de l'exemple anterior, ja que la funci√≥  \texttt{inverse\_laplace\_transform} no √©s capa√ß de trobar la transformada de Laplace inversa de la funci√≥: 
\[
\frac{\sqrt{2}\times 110\times 10^6 s}{(s^2 + 1000 s + 500000)(s^2 + (100\piup)^2)}
\]
El programa queda aturat calculant indefinidament, sense arribar a donar cap resultat.  Aquest problema es resol, a vegades, substituint valors num√®rics per variables simb√≤liques declarades amb l'opci√≥ \texttt{real=True}. En el nostre cas, la funci√≥ \texttt{inverse\_laplace\_transform} troba sense dificultat la transformada de Laplace inversa de la funci√≥:
\[
\frac{a s}{(s^2 + 1000 s + 500000)(s^2 + \omega^2)}
\]
A continuaci√≥, nom√©s cal substituir en la soluci√≥ les variables $a$ i $\omega$ pels valors $\sqrt{2}\times 110\times 10^6$ i $100\piup$ respectivament.


\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:CircuitLaplaceNul} \CircuitLaplaceNul},label=lst:CircuitLaplaceNul]{Python/Exemple-5-4.py}


Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}[mathescape=true]
	
uC(t) = 11000*sqrt(2)*(10*pi*exp(500*t)*sin(100*pi*t) - pi**2*exp(500*t)*cos(100*pi*t) + 50*exp(500*t)*cos(100*pi*t) - 50*sin(500*t) - pi**2*sin(500*t) - 50*cos(500*t) + pi**2*cos(500*t))*exp(-500*t)/(pi**4 + 2500)


$ \includegraphics{Cap-PythonExemp-CircuitLaplaceNul.pdf} $
\end{lstlisting} 



\section{Exemples del cap√≠tol \ref*{sec:ch-cables}}

\hypertarget{exemple:CaigudaDeTensio}{\subsection{Exemple \ref*{ex:CaigudaDeTensio} \CaigudaDeTensio}}
En el llistat \vref{lst:CaigudaDeTensio} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:CaigudaDeTensio}. La resoluci√≥ es fa usant el m√≤dul num√®ric \texttt{numpy} i  la funci√≥ \texttt{voltage\_drop} del m√≤dul \texttt{qed.eng\_elec}.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:CaigudaDeTensio} \CaigudaDeTensio},label=lst:CaigudaDeTensio]{Python/Exemple-7-1.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}
Caiguda de tensi√≥: 11.20 V (5.10 %)
\end{lstlisting} 



\hypertarget{exemple:AWGammSQ}{\subsection{Exemple \ref*{ex:AWGammSQ} \AWGammSQ}}
En el llistat \vref{lst:AWGammSQ} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:AWGammSQ}. La resoluci√≥ es fa usant la funci√≥ \texttt{AWG\_to\_mm2} del m√≤dul \texttt{qed.eng\_elec}.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:AWGammSQ} \AWGammSQ},label=lst:AWGammSQ]{Python/Exemple-7-3.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}
AWG 14 equival a 2.1 mm¬≤
\end{lstlisting} 



\hypertarget{exemple:mmSQaAWG}{\subsection{Exemple \ref*{ex:mmSQaAWG} \mmSQaAWG}}
En el llistat \vref{lst:mmSQaAWG} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:mmSQaAWG}. La resoluci√≥ es fa usant la funci√≥ \texttt{mm2\_to\_AWG} del m√≤dul \texttt{qed.eng\_elec}.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:mmSQaAWG} \mmSQaAWG},label=lst:mmSQaAWG]{Python/Exemple-7-4.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}
4 mm¬≤ equival a AWG 11
\end{lstlisting} 





\section{Exemples del cap√≠tol \ref*{sec:ch-trafos-pot}}

\hypertarget{exemple:ParamTrafo}{\subsection{Exemple \ref*{ex:ParamTrafo} \ParamTrafo}}
En el llistat \vref{lst:ParamTrafo} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:ParamTrafo}. La resoluci√≥ es fa usant funcions del m√≤dul num√®ric \texttt{numpy} i la classe  \texttt{ComplexD} del m√≤dul \texttt{qed.utils}.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:ParamTrafo} \ParamTrafo},label=lst:ParamTrafo]{Python/Exemple-9-1.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}
g_Fe = 0.0050
b_m = 0.0194
r = 0.0100
x = 0.0387

s_2 = 0.5000+0.3750j
u_2 = 0.9500

i_2 = 0.6579‚à†-36.87¬∞
i_0 = 0.0190‚à†-75.52¬∞
i_1 = 0.6728‚à†-37.88¬∞

u_1 = 0.9715‚à†0.97¬∞
U_1 = 24286.3‚à†0.97¬∞ V

Œî_u = 0.0215
Œî_U2 = 8.5801 V

p_Cu = 0.004527
p_Fe = 0.004513
Œ∑ = 0.98
\end{lstlisting} 

Es pot observar que algun dels valors obtinguts no √©s exactament igual al valor obtingut en la resoluci√≥ manual; aquesta difer√®ncia es deu  al fet que en la resoluci√≥ manual s'han utilitzat nom√©s quatre xifres decimals pels m√≤duls i dues pels angles, mentre que el programa treballa sempre amb tota la precisi√≥ de les variables (t√≠picament, setze xifres decimals).




\section{Exemples del cap√≠tol \ref*{sec:ch-motors-ind}}

\hypertarget{exemple:MotTempsArr}{\subsection{Exemple \ref*{ex:MotTempsArr} \MotTempsArr}}
En el llistat \vref{lst:MotTempsArr} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:MotTempsArr}. La resoluci√≥ es fa fent √∫s de funcions del m√≤dul num√®ric \texttt{numpy} i del m√≤dul d'integraci√≥ num√®rica \texttt{scipy.integrate}. D'aquest darrer m√≤dul s'utilitza la funci√≥ \texttt{trapezoid} per fer la integraci√≥ num√®rica amb el m√®tode dels trapezis ---tal com es fa manualment en l'exemple--- i la funci√≥ \texttt{simpson} per fer la integraci√≥ num√®rica amb el m√®tode de Simpson, per tal d'obtenir un resultat m√©s prec√≠s; la funci√≥ \texttt{simpson} pot treballar amb divisions d'amplada diferent, tal com √©s el cas d'aquest exemple. 
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:MotTempsArr} \MotTempsArr},label=lst:MotTempsArr]{Python/Exemple-10-3.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}
Temps d'arrencada (trapezoid) = 13.5 s
Temps d'arrencada (simpson)   = 12.9 s
\end{lstlisting} 


\hypertarget{exemple:CaractMotor}{\subsection{Exemple \ref*{ex:CaractMotor} \CaractMotor}}
En el llistat \vref{lst:CaractMotor} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:CaractMotor}. La resoluci√≥ es fa usant funcions del m√≤dul num√®ric \texttt{numpy} i del m√≤dul gr√†fic \texttt{matplotlib}, i la classe \texttt{Motor3ph} del m√≥dul \texttt{qed.eng\_elc}. Es fa servir tamb√© la classe \texttt{ComplexD} del m√≤dul \texttt{qed.utils}.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:CaractMotor} \CaractMotor},label=lst:CaractMotor]{Python/Exemple-10-4.py}

El programa calcula, addicionalment a l'exemple resolt a m√†, els valors seg√ºents: 
\begin{itemize}
	\item Relaci√≥ entre el corrent d'arrencada i el corrent nominal.
	\item Corrent de pic asim√®tric d'arrencada.
	\item Relaci√≥ entre el corrent de pic asim√®tric d'arrencada i el corrent d'arrencada.
	\item   Pot√®ncia mec√†nica d'arrencada ---igual a zero, com era d'esperar.
	\item Relaci√≥ entre el parell mec√†nic d'arrencada i el parrell mec√†nic nominal.
	\item Factor de pot√®ncia d'arrencada.
	\item Velocitat en rad/s del parell mec√†nic m√†xim.
	\item Relaci√≥ entre el parell mec√†nic m√†xim i el parrell mec√†nic nominal.
\end{itemize}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}

\begin{lstlisting}[mathescape=true]
U_1 = 219.393 V
n_m,sinc = 1500 r/min,  œâ_m,sinc = 157.080 rad/s
n_m,n = 1425.0 r/min,  œâ_m,n = 149.226 rad/s

I_1,n = 17.7 A
I_1,arr = 74.9 A,  I_1,arr/I_1,n = 4.2
I_1,arr,pic,asim = 139.2 A,  I_1,arr,pic,asim/I_1,arr = 1.86

P_m,n = 9052.8 W
P_m,arr = 0.0 W

T_m,n = 60.7 N¬∑m
T_m,arr = 62.8 N¬∑m,  T_m,arr/T_m,n = 1.04

cos ùúë,n = 0.8874
cos ùúë,arr = 0.3725

Œ∑,n = 0.8761

s,T_m,max = 0.2283,  n,T_m,max = 1157.6 r/min,  œâ,T_m,max = 121.226 rad/s
T_m,max = 132.7 N¬∑m,  T_m,max/T_m,n = 2.19



$ \includegraphics{Cap-PythonExemp-CaractMotor-1.pdf} $
    
    
    
    
    
    
    
    
    
    
$ \includegraphics{Cap-PythonExemp-CaractMotor-2.pdf} $



$ \includegraphics{Cap-PythonExemp-CaractMotor-3.pdf} $
\end{lstlisting} 






\hypertarget{exemple:TensDeseqMotor}{\subsection{Exemple \ref*{ex:TensDeseqMotor} \TensDeseqMotor}}
En el llistat \vref{lst:TensDeseqMotor} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:TensDeseqMotor}. La resoluci√≥ es fa fent servir funcions del m√≤dul \texttt{qed.eng\_elec}. Es fa servir tamb√© la classe \texttt{ComplexD} del m√≤dul \texttt{qed.utils}.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:TensDeseqMotor} \TensDeseqMotor},label=lst:TensDeseqMotor]{Python/Exemple-10-5.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}
U_AB = 399.00‚à†0.00¬∞ V
U_BC = 370.00‚à†-122.63¬∞ V
U_CA = 370.00‚à†122.63¬∞ V

U_AB,1 = 379.41‚à†-0.00¬∞ V
U_AB,2 = 19.59‚à†0.00¬∞ V
U_AB,0 = 0.00‚à†0.00¬∞ V

U_AN,1 = 219.05‚à†-30.00¬∞ V
U_AN,2 = 11.31‚à†30.00¬∞ V
U_AN,2/U_AN,1 = 0.052

Z_mot,n,1 = 11.004+5.718j Œ©
Z_mot,n,2 = 0.805+2.712j Œ©
Z_mot,arr,1 = 1.091+2.717j Œ©

I_1,n,1 = 17.66‚à†-57.46¬∞ A
I_1,n,2 = 4.00‚à†-43.47¬∞ A
I_1,n,2/I_1,n,1 = 0.226

I_1,n,A = 21.57‚à†-54.89¬∞ A
I_1,n,B = 17.00‚à†169.48¬∞ A
I_1,n,C = 15.16‚à†73.48¬∞ A
\end{lstlisting} 


\hypertarget{exemple:MotCarregaReduida}{\subsection{Exemple \ref*{ex:MotCarregaReduida} \MotCarregaReduida}}
En el llistat \vref{lst:MotCarregaReduida} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:MotCarregaReduida}. La resoluci√≥ es fa emprant funcions del m√≤dul num√®ric \texttt{numpy} i del m√≤dul gr√†fic \texttt{matplotlib}, la funci√≥ \texttt{root} del m√≤dul matem√†tic \texttt{scipy.optimize}, i la classe \texttt{Motor3ph} del m√≤dul \texttt{qed.eng\_elec}. La funci√≥ \texttt{root} calcula el valor de $s$ resolent una equaci√≥ no lineal; com a valor inicial per resoldre-la  s'utilitza el valor de $s\ped{n}$.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:MotCarregaReduida} \MotCarregaReduida},label=lst:MotCarregaReduida]{Python/Exemple-10-6.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}[mathescape=true]
U_1 = 219.393 V

P_m,50% = 4526.4 W
s,50% = 0.0226

Z_mot,50% = 18.015+13.510j Œ©

I_1,50% = 9.7 A
I_1,50%/I_1,n = 0.6

cos ùúë,50% = 0.8000
Œ∑,50% = 0.8823



$ \includegraphics{Cap-PythonExemp-MotCarregaReduida-1.pdf} $













$ \includegraphics{Cap-PythonExemp-MotCarregaReduida-2.pdf} $
\end{lstlisting} 


\hypertarget{exemple:MotTensRedSolAp}{\subsection{Exemple \ref*{ex:MotTensRedSolAp} \MotTensRedSolAp}}
En el llistat \vref{lst:MotTensRedSolAp} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:MotTensRedSolAp}. La resoluci√≥ es fa emprant funcions del m√≤dul num√®ric \texttt{numpy} i del m√≤dul gr√†fic \texttt{matplotlib}, i la funci√≥ \texttt{root} del m√≤dul matem√†tic \texttt{scipy.optimize}. La funci√≥ \texttt{root} calcula el valor de $s$ resolent una equaci√≥ no lineal; com a valor inicial per resoldre-la  s'utilitza el valor de $s\ped{n}$.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:MotTensRedSolAp} \MotTensRedSolAp},label=lst:MotTensRedSolAp]{Python/Exemple-10-7.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}[mathescape=true]
P_m,n = 9052.8 W
U_1,80% = 175.514 V
s,80% = 0.0971

Z_mot,80% = 6.324+3.565j Œ©

I_1,80% = 24.2 A
I_1,80%/I_1,n = 1.4

cos ùúë,80% = 0.8711
Œ∑,80% = 0.8163
	
$ \includegraphics{Cap-PythonExemp-MotTensRedSolAp-1.pdf} $

$ \includegraphics{Cap-PythonExemp-MotTensRedSolAp-2.pdf} $
\end{lstlisting} 



\hypertarget{exemple:MotTensRedSolEx}{\subsection{Exemple \ref*{ex:MotTensRedSolEx} \MotTensRedSolEx}}
En el llistat \vref{lst:MotTensRedSolEx} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:MotTensRedSolEx}. La resoluci√≥ es fa usant funcions del m√≤dul num√®ric \texttt{numpy} i del m√≤dul gr√†fic \texttt{matplotlib}, i la classe \texttt{Motor3ph} del m√≤dul \texttt{qed.eng\_elec}. La funci√≥ \texttt{root} calcula el valor de $s$ resolent una equaci√≥ no lineal; com a valor inicial per resoldre-la  s'utilitza el valor de $s\ped{n}$.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:MotTensRedSolEx} \MotTensRedSolEx},label=lst:MotTensRedSolEx]{Python/Exemple-10-8.py}

El programa calcula, addicionalment a l'exemple resolt a m√†, els valors de la imped√†ncia del motor i  del temps que triga el motor a arrencar, al 100 \% i al 80 \% de la tensi√≥ nominal. Tamb√© es representa l'evoluci√≥ temporal del  corrent d'arrencada a aquestes dues tensions.

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}[mathescape=true]
	
U_1,100% = 219.393 V
U_1,80% = 175.514 V

n_m,sinc = 1500 r/min,  œâ_m,sinc = 157.080 rad/s

s,100% = 0.0461
n_m,100% = 1430.8 r/min
Z_mot,100% = 11.703+6.182j Œ©
I_1,100% = 16.6 A
I_1,arr,100% = 74.9 A
Tm,100% = 56.6 N¬∑m
Tm,arr,100% = 62.8 N¬∑m
cos ùúë,100% = 0.8842
Œ∑,100% = 0.8797
t_arr,100% = 5.2 s

s,80% = 0.0746
n_m,80% = 1388.0 r/min
Z_mot,80% = 7.926+4.135j Œ©
I_1,80% = 19.6 A
I_1,arr,80% = 59.9 A
Tm,80% = 53.4 N¬∑m
Tm,arr,80% = 40.2 N¬∑m
cos ùúë,80% = 0.8866
Œ∑,80% = 0.8468
t_arr,80% = 9.1 s

$ \includegraphics{Cap-PythonExemp-MotTensRedSolEx-1-1.pdf} $




$ \includegraphics{Cap-PythonExemp-MotTensRedSolEx-1-2.pdf} $




$ \includegraphics{Cap-PythonExemp-MotTensRedSolEx-2-1.pdf} $




$ \includegraphics{Cap-PythonExemp-MotTensRedSolEx-2-2.pdf} $




$ \includegraphics{Cap-PythonExemp-MotTensRedSolEx-3.pdf} $
\end{lstlisting} 



\hypertarget{exemple:MotTensRedIarr}{\subsection{Exemple \ref*{ex:MotTensRedIarr} \MotTensRedIarr}}
En el llistat \vref{lst:MotTensRedIarr} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:MotTensRedIarr}. La resoluci√≥ es fa emprant funcions del m√≤dul num√®ric \texttt{numpy} i del m√≤dul gr√†fic \texttt{matplotlib}, i la classe \texttt{Motor3ph} del m√≤dul \texttt{qed.eng\_elec}. La funci√≥ \texttt{root} calcula el valor de $s$ resolent una equaci√≥ no lineal; com a valor inicial per resoldre-la  es fa servir el valor de $s\ped{n}$. Es fa servir tamb√© la classe \texttt{ComplexD} del m√≤dul \texttt{qed.utils}.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:MotTensRedIarr} \MotTensRedIarr},label=lst:MotTensRedIarr]{Python/Exemple-10-9.py}

El programa calcula, addicionalment a l'exemple resolt a m√†, el valor  del temps que triga el motor a arrencar. Tamb√© es representa l'evoluci√≥ temporal del  corrent d'arrencada i de la tensi√≥ en el motor.

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}[mathescape=true]
U_1,sist = 219.393 V
Z_sist = 0.003+0.029j Œ©
Z_cable = 0.317+0.010j Œ©

n_m,sinc = 1500 r/min,  œâ_m,sinc = 157.080 rad/s

s,fun = 0.0485,   n_m_fun = 1427.3 r/min
U_1,fun = 214.305‚à†0.502¬∞ V
I_1,fun = 16.9 A
T_m,fun = 56.4 N¬∑m

U_1,arr = 207.494‚à†5.238¬∞ V
I_1,arr = 70.9 A
T_m,arr = 56.2 N¬∑m

s_T_m,max = 0.2197
n_T_m,max = 1170.5 r/min
T_m,max = 117.5 N¬∑m

t_arr = 6.0 s


















$ \includegraphics{Cap-PythonExemp-MotTensRedIarr-1.pdf} $



$ \includegraphics{Cap-PythonExemp-MotTensRedIarr-2.pdf} $






$ \includegraphics{Cap-PythonExemp-MotTensRedIarr-3.pdf} $



$ \includegraphics{Cap-PythonExemp-MotTensRedIarr-4.pdf} $
\end{lstlisting} 




\section{Exemples del cap√≠tol \ref*{sec:ch-xarxes-elec}}

\hypertarget{exemple:XarxaAmbAcobl}{\subsection{Exemple \ref*{ex:XarxaAmbAcobl} \XarxaAmbAcobl}}
En el llistat \vref{lst:XarxaAmbAcobl} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:XarxaAmbAcobl}. S'utilitzen les classes \texttt{Network}, \texttt{MutualCoupling}, \texttt{VoltageSource}, \texttt{CurrentSource} i \texttt{Impedance} del m√≤dul \texttt{qed.eng\_elec},  per resoldre la xarxa.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:XarxaAmbAcobl} \XarxaAmbAcobl},label=lst:XarxaAmbAcobl]{Python/Exemple-11-1.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}
 Branch   Voltage / pu      Current / pu
--------  ----------------  ----------------
   1      1.0494‚à†178.5091¬∞  0.2312‚à†-61.8063¬∞
   2      1.0175‚à†177.4776¬∞  0.7431‚à†-13.0406¬∞
   3      0.9727‚à†169.6442¬∞  1.2782‚à†-22.6715¬∞
   4      0.1495‚à†67.0039¬∞   1.4946‚à†-22.9961¬∞
   5      0.2925‚à†66.2049¬∞   0.6955‚à†-23.7522¬∞
   6      0.1431‚à†65.3702¬∞   0.2166‚à†-24.9115¬∞
   7      0.0370‚à†28.1937¬∞   0.2312‚à†-61.8063¬∞
   8      0.9512‚à†-19.1752¬∞  2.1901‚à†-23.2362¬∞

s_G1 = 0.1201+0.2241j
s_G2 = 0.7433+0.2484j
s_G3 = 1.2146+0.6736j
s_Q8 = 2.0781+0.1475j
\end{lstlisting} 


\hypertarget{exemple:XarxaSenseAcobl}{\subsection{Exemple \ref*{ex:XarxaSenseAcobl} \XarxaSenseAcobl}}
En el llistat \vref{lst:XarxaSenseAcobl} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:XarxaSenseAcobl}. S'utilitzen les classes \texttt{Network},  \texttt{VoltageSource}, \texttt{CurrentSource} i \texttt{Impedance} del m√≤dul \texttt{qed.eng\_elec} per resoldre la xarxa.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:XarxaSenseAcobl} \XarxaSenseAcobl},label=lst:XarxaSenseAcobl]{Python/Exemple-11-2.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}
I2 = -0.0294-3.1176j A
I5 = 0.8235-3.2059j A
\end{lstlisting} 

\hypertarget{exemple:XarxaThevenin}{\subsection{Exemple \ref*{ex:XarxaThevenin} \XarxaThevenin}}
En el llistat \vref{lst:XarxaThevenin} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:XarxaThevenin}. S'utilitzen les classes \texttt{Network}, \texttt{MutualCoupling}, \texttt{VoltageSource}, \texttt{CurrentSource} i \texttt{Impedance} del m√≤dul \texttt{qed.eng\_elec} per resoldre la xarxa.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:XarxaThevenin} \XarxaThevenin},label=lst:XarxaThevenin]{Python/Exemple-11-3.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}
E_Th(1,2) = 119.2079+2.0792j V
Z_Th(1,2) = 4.2574+2.5743j Œ©
J_No(1,2) = 20.7200-12.0400j A
Y_No(1,2) = 0.1720-0.1040j S
\end{lstlisting} 



\section{Exemples del cap√≠tol \ref*{sec:ch-flux-carregues}}

\hypertarget{exemple:FluxCarrXarxa}{\subsection{Exemple \ref*{ex:FluxCarrXarxa} \FluxCarrXarxa}}
En el llistat \vref{lst:FluxCarrXarxa} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:FluxCarrXarxa}. Es fan servir dos m√®todes diferents.

El primer m√®tode es basa en la resoluci√≥ directa del sistema d'equacions no lineals de l'exemple, fent servir funcions del m√≤dul num√®ric \texttt{numpy}, del m√≤dul de matem√†tica num√®rica \texttt{scipy} i del m√≤dul de matem√†tica simb√≤lica \texttt{sympy}. Primer es defineixen de forma simb√≤lica les variables i el sistema d'equacions a resoldre usant les funcions \texttt{symbols}, \texttt{SIN} i \texttt{COS}, i despr√©s se n'obt√© el jacobi√† usant les funcions \texttt{Matrix} i \texttt{jacobian}; a continuaci√≥ es fa √∫s de la funci√≥  \texttt{lambdify} per crear les versions num√®riques corresponents al sistema d'equacions i al jacobi√†, i finalment es resol el sistema amb la funci√≥ \texttt{optimize.root}. Les funcions sinus i cosinus simb√≤liques s√≥n  \texttt{sympy.sin} i  \texttt{sympy.cos} respectivament, no obstant aix√≤,  per tal de fer m√©s llegible les equacions es defineixen els √†lies \texttt{SIN} i \texttt{COS} per a aquestes dues funcions trigonom√®triques.

El segon m√®tode est√† basat en el m√≤dul \texttt{pandapower}. En aquest cas s'introdueixen les dades dels components de la xarxa (generadors, l√≠nies, consums, etc.), i el flux de c√†rregues s'obt√© directament sense necessitat de plantejar cap equaci√≥. Aquest m√≤dul treballa amb unes unitats fixes: tensions en  \unit{kV}, pot√®ncies en  \unit{MVA}, \unit{MW} i \unit{Mvar}, imped√†ncies longitudinals de l√≠nies en \unit{\ohm/km}, i longituds de l√≠nies en  \unit{km}. En el nostre cas, tenim una xarxa expressada amb valors en per unitat, i no coneixem els valors reals dels components. Aquesta dificultat es pot superar usant com a pot√®ncia base de la xarxa \qty{1}{MVA}, assignant a tots els nusos una tensi√≥ de \qty{1}{kV}, i assignant una longitud de \qty{1}{km} a totes les l√≠nies; d'aquesta manera, la imped√†ncia base valdr√†: $(\qty{1}{kV})^2/\qty{1}{MVA} = \qty{1}{\ohm}$. Amb aquests valors aix√≠ escollits, aconseguim que els valors num√®rics expressats en per unitat siguin id√®ntics als valors num√®rics expressats en 
\unit{kV},  \unit{MVA}, \unit{MW}, \unit{Mvar} i \unit{\ohm/km}, segons el cas.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:FluxCarrXarxa} \FluxCarrXarxa},label=lst:FluxCarrXarxa]{Python/Exemple-12-1.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}
Œ¥_2 = -0.015277 rad = -0.875336¬∞
v_3 = 1.033587
Œ¥_3 = -0.014301 rad = -0.819384¬∞

s_1 = 0.85681+0.52171j
s_2 = -0.25000-0.20049j
s_G1 = 0.85681+0.52171j
s_G2 = 0.25000+0.04951j

Tensions i pot√®ncies del nusos
      vm_pu  va_degree     p_mw    q_mvar
1  1.050000   0.000000 -0.85681 -0.521705
2  1.030000  -0.875336  0.25000  0.200493
3  1.033587  -0.819384  0.60000  0.300000

Pot√®ncia generada en el nus 1
      p_mw    q_mvar
1  0.85681  0.521705

Pot√®ncia generada en el nus 2
   p_mw    q_mvar  va_degree  vm_pu
2  0.25  0.049507  -0.875336   1.03
\end{lstlisting} 


\hypertarget{exemple:ControlTensCond}{\subsection{Exemple \ref*{ex:ControlTensCond} \ControlTensCond}}
En el llistat \vref{lst:ControlTensCond} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:ControlTensCond}. Es fan servir dos m√®todes diferents.

El primer m√®tode es basa en la resoluci√≥ directa dels sistemes d'equacions no lineals de l'exemple. Per resoldre l'apartat a)   es fan servir funcions del m√≤dul num√®ric \texttt{numpy}, del m√≤dul de matem√†tica num√®rica \texttt{scipy} i del m√≤dul de matem√†tica simb√≤lica \texttt{sympy}. Primer es defineixen de forma simb√≤lica les variables i el sistema d'equacions a resoldre usant les funcions \texttt{symbols}, \texttt{SIN} i \texttt{COS}, i despr√©s se n'obt√© el jacobi√† usant les funcions \texttt{Matrix} i \texttt{jacobian}; a continuaci√≥ es fa √∫s de la funci√≥  \texttt{lambdify} per crear les versions num√®riques corresponents al sistema d'equacions i al jacobi√†, i finalment es resol el sistema amb la funci√≥ \texttt{optimize.root}. L'apartat b) de l'exemple es resol de forma similar, per√≤ com que nom√©s tenim una equaci√≥, en lloc de les funcions \texttt{Matrix}, \texttt{jacobian} i \texttt{optimize.root}, es fan servir les funcions \texttt{diff} i \texttt{optimize.root\_scalar}. Les funcions sinus i cosinus simb√≤liques s√≥n  \texttt{sympy.sin} i  \texttt{sympy.cos} respectivament, no obstant aix√≤,  per tal de fer m√©s llegible les equacions es defineixen els √†lies \texttt{SIN} i \texttt{COS} per a aquestes dues funcions trigonom√®triques.

El segon m√®tode est√† basat en el m√≤dul \texttt{pandapower}. S√≥n d'aplicaci√≥ les mateixes consideracions de l'exemple anterior, sobre les unitats que cal utilitzar. En aquest cas tenim addicionalment l'admit√†ncia transversal d'una l√≠nia, que \texttt{pandapower} requereix que s'expressi en \unit{nF/km}; ens caldr√† doncs dividir el nostre valor d'admit√†ncia en per unitat, per $2 \pi f$ (amb $f = \qty{50}{Hz}$), i multiplicar el resultat per $10^9$, per tal d'obtenir el valor en les unitats necess√†ries. En el cas de l'apartat  b) de l'exemple, el banc de condensadors es modela com un generador connectat al nus 2, amb una pot√®ncia activa  igual a zero.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}


\lstinputlisting[caption={Python --- Exemple \ref*{ex:ControlTensCond} \ControlTensCond},label=lst:ControlTensCond]{Python/Exemple-12-2.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}
Cas a)
---------------------------------------------
v_2 = 0.970306
Œ¥_2 = -0.060222 rad = -3.450451¬∞

s_12 = 0.82813+0.59423j
s_G1 = 2.02813+0.89423j

Tensions i pot√®ncies del nusos
      vm_pu  va_degree      p_mw    q_mvar
1  1.050000   0.000000 -0.828126 -0.594232
2  0.970306  -3.450451  0.800000  0.600000

Pot√®ncia generada en el nus 1
       p_mw    q_mvar
1  2.028126  0.894232

Cas b)
---------------------------------------------
Œ¥_2 = -0.072323 rad = -4.143827¬∞

s_12 = 0.81695-0.04520j
s_21 = -0.80000-0.00484j
s_G1 = 2.01695+0.25480j
s_C2 = -0.00000+0.59516j

Tensions i pot√®ncies del nusos
   vm_pu  va_degree      p_mw    q_mvar
1   1.05   0.000000 -0.816953  0.045202
2   1.03  -4.143827  0.800000  0.004844

Pot√®ncia generada en el nus 1
       p_mw    q_mvar
1  2.016953  0.254798

Pot√®ncia generada en el nus 2
   p_mw    q_mvar  va_degree  vm_pu
2   0.0  0.595156  -4.143827   1.03
\end{lstlisting} 


\hypertarget{exemple:ControlTensTrafo}{\subsection{Exemple \ref*{ex:ControlTensTrafo} \ControlTensTrafo}}
En el llistat \vref{lst:ControlTensTrafo} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:ControlTensTrafo}. Es fan servir dos m√®todes diferents.

El primer m√®tode es basa en la resoluci√≥ directa del sistema d'equacions no lineals de l'exemple, fent servir funcions  del m√≤dul de matem√†tica num√®rica \texttt{scipy} i del m√≤dul de matem√†tica simb√≤lica \texttt{sympy}. Primer es defineixen de forma simb√≤lica les variables i el sistema d'equacions a resoldre usant les funcions \texttt{symbols}, \texttt{sin} i \texttt{cos}, i despr√©s se n'obt√© el jacobi√† usant les funcions \texttt{Matrix} i \texttt{jacobian}; a continuaci√≥ es fa √∫s de la funci√≥  \texttt{lambdify} per crear les versions num√®riques corresponents al sistema d'equacions i al jacobi√†, i finalment es resol el sistema amb la funci√≥ \texttt{optimize.root}.

El segon m√®tode est√† basat en el m√≤dul \texttt{pandapower}. S√≥n d'aplicaci√≥ les mateixes consideracions dels exemples anteriors, sobre les unitats que cal utilitzar. En aquest cas tenim addicionalment un transformador, al qual li assignarem una pot√®ncia de \qty{1}{MVA}, i una tensi√≥ prim√†ria i secund√†ria de \qty{1}{kV}; amb aquests valors, nom√©s caldr√† multiplicar per 100 la imped√†ncia en per unitat  del transformador per tal d'obtenir el valor en tant per cent, que requereix \texttt{pandapower}. A m√©s, donat que el que busquem √©s la relaci√≥ de transformaci√≥ del transformador, √©s obligat definir quan es crea el transformador els par√†metres: \texttt{tap\_side='hv'}, \texttt{tap\_step\_percent=1}, \texttt{tap\_min=--10}, \texttt{tap\_max=10}, \texttt{tap\_neutral=0} i  \texttt{tap\_pos=0}; els valors de \texttt{tap\_min} i \texttt{tap\_max} s√≥n arbitraris, per√≤ han de ser prou grans perqu√® el valor final calculat de \texttt{tap\_pos} quedi dins del marge que defineixen. Addicionalment, cal fer servir la funci√≥ \texttt{ContinuousTapControl} del m√≤dul \texttt{pandapower.control}, inicialitzant-la amb el valor \texttt{vm\_set\_pu=1}, que √©s el valor del m√≤dul de la tensi√≥ que volem mantenir en el secundari del transformador.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:ControlTensTrafo} \ControlTensTrafo},label=lst:ControlTensTrafo]{Python/Exemple-12-3.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}
Œ¥_2 = -0.039196 rad = -2.245743¬∞
m = 0.979639

Tensions i pot√®ncies del nusos
   vm_pu  va_degree  p_mw  q_mvar
1    1.0   0.000000  -2.0    -1.1
2    1.0  -2.245744   2.0     1.0

Posici√≥ del "tap" = -2.036057

Relaci√≥ de transformaci√≥ = 0.979639
\end{lstlisting}

Es comprova que el valor calculat de \texttt{tap\_pos} est√† dins dels marges establerts (entre $-10$ i 10, en el nostre cas); si no fos aix√≠, la tensi√≥ del nus 2 no hauria arribat al valor fixat de \qty{1}{pu}, i caldria augmentar aquests marges.


\section{Exemples del cap√≠tol \ref*{sec:ch-normes}}

\hypertarget{exemple:ProtInvIntVar}{\subsection{Exemple \ref*{ex:ProtInvIntVar} \ProtInvIntVar}}
En el llistat \vref{lst:ProtInvIntVar} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:ProtInvIntVar}. Es fan servir funcions  del m√≤dul num√®ric \texttt{numpy}, del m√≤dul de matem√†tica num√®rica \texttt{scipy} i del m√≤dul gr√†fic \texttt{matplotlib}. A partir de l'equaci√≥ \eqref{eq:50-51}, es fa servir la funci√≥  \texttt{optimize.root} del m√≤dul \texttt{scipy} per trobar el valor de $\tauup$ que compleix: $\int_0^\tauup \frac{1}{t_{51}(I(t))}  \diff t - 1 = 0$; aquesta  funci√≥ requereix un valor inicial de la soluci√≥, a partir del qual comen√ßa a calcular-ne el valor exacte. Si mirem la gr√†fica de l'exemple \ref{ex:ProtInvIntVar}, veiem a ull que el corrent inicial √©s d'uns \qty{30}{kA}, i que amb aquest valor mantingut la funci√≥ 51 actuaria en uns \qty{0,22}{s}; donat que el temps d'actuaci√≥ ha de ser superior a aquest valor, farem servir \qty{0,25}{s} com a valor inicial per a la funci√≥ \texttt{optimize.root}. Aquesta funci√≥, a m√©s de la soluci√≥ num√®rica, tamb√©  dona informaci√≥ addicional; en particular, el par√†metre boole√† \texttt{success} indica si s'ha obtingut o no una soluci√≥ correcta, i el  par√†metre de text \texttt{message}  dona informaci√≥ sobre la soluci√≥ obtinguda. La integral $\int_0^\tauup \frac{1}{t_{51}(I(t))}  \diff t$ es calcula amb la funci√≥ \texttt{integrate.quad} del m√≤dul \texttt{scipy}, que dona resultats m√©s precisos que la integraci√≥ pel m√®tode dels trapezis. 
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:ProtInvIntVar} \ProtInvIntVar},label=lst:ProtInvIntVar]{Python/Exemple-13-1.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}[mathescape=true]
$ \includegraphics{Cap-PythonExemp-ProtInvIntVar.pdf} $

T = 0.6
-----------------------------------
Temps calculat d'actuaci√≥: 0.4096 s
Valor de la integral: 1.0000

    fjac: array([[-1.]])
     fun: 0.0
message: 'The solution converged.'
    nfev: 9
     qtf: array([1.29452005e-13])
       r: array([-1.2877028])
  status: 1
 success: True
       x: array([0.40957008])

T = 0.8
-----------------------------------
Temps calculat d'actuaci√≥: 0.6462 s
Valor de la integral: 0.8647

    fjac: array([[-1.]])
     fun: -0.13533445834807245
message: 'The iteration is not making good progress, as measured by the
  improvement from the last ten iterations.'
    nfev: 26
     qtf: array([0.13533446])
       r: array([-0.00016336])
  status: 5
 success: False
       x: array([0.6461866])
\end{lstlisting}


En aquest programa es resolen dos casos. El primer ---amb el valor multiplicatiu T = 0,6 de la funci√≥ $t_{51}(I)$--- √©s el mateix que el de l'exemple resolt a m√†; el valor \texttt{True} del par√†metre \texttt{success} i el text  \texttt{¬´The solution converged.¬ª} del par√†metre \texttt{message}, confirmen que el valor calculat de \qty{0,4096}{s} √©s correcte, i que, per tant, la protecci√≥ 51 actua; una altra constataci√≥ del fet que la protecci√≥ actua, √©s el valor de la integral igual a 1. El Segon cas ---amb el valor multiplicatiu T = 0,8 de la funci√≥ $t_{51}(I)$--- dona el valor \texttt{False} del par√†metre \texttt{success} i el text  \texttt{¬´The iteration is not making good progress, as measured by the improvement from the last ten iterations.¬ª} del par√†metre \texttt{message}, indicant que el valor calculat de \qty{0,6462}{s} no √©s correcte, i que, per tant, la protecci√≥ 51 no actua; una altra ratificaci√≥ del fet que la protecci√≥ no actua, √©s el valor de la integral de 0,8647, menor que 1. 


\section{Exemples de l'ap√®ndix \ref*{sec:ch-calc-num}}

\hypertarget{exemple:InterpLinCub}{\subsection{Exemple \ref*{ex:InterpLinCub} \InterpLinCub}}
En el llistat \vref{lst:InterpLinCub} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:InterpLinCub}. S'utilitza la funci√≥ \texttt{interp1d} del m√≤dul \texttt{scipy.interpolate} per fer la interpolaci√≥.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}



\lstinputlisting[caption={Python --- Exemple \ref*{ex:InterpLinCub} \InterpLinCub},label=lst:InterpLinCub]{Python/Exemple-E-1.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}
Interpolaci√≥ lineal: 0.9975
Interpolaci√≥ c√∫bica: 1.0000
\end{lstlisting} 


\hypertarget{exemple:InterpDuesDim}{\subsection{Exemple \ref*{ex:InterpDuesDim} \InterpDuesDim}}
En el llistat \vref{lst:InterpDuesDim} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:InterpDuesDim}. A m√©s de la interpolaci√≥ lineal, tamb√© es fa servir la interpolaci√≥ c√∫bica ---m√©s precisa--- per resoldre l'exemple. S'utilitza la funci√≥ \texttt{interp2d} del m√≤dul \texttt{scipy.interpolate} per fer la interpolaci√≥.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:InterpDuesDim} \InterpDuesDim},label=lst:InterpDuesDim]{Python/Exemple-E-2.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}
Interpolaci√≥ lineal: 4.20 cP
Interpolaci√≥ c√∫bica: 4.12 cP
\end{lstlisting} 

La funci√≥ \texttt{interp2d} requereix un nombre de punts $n$ m√≠nim: $n \geq (k+1)^2$, amb $k=1$ per a una interpolaci√≥ lineal, $k=3$ per a una interpolaci√≥ c√∫bica, i $k=5$ per a una interpolaci√≥ de cinqu√® grau. En el nostre cas tenim 16 punts, que √©s el m√≠nim necessari en el cas de $k=3$.

\hypertarget{exemple:IntegracioNum}{\subsection{Exemple \ref*{ex:IntegracioNum} \IntegracioNum}}
En el llistat \vref{lst:IntegracioNum} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:IntegracioNum}. A m√©s de la integraci√≥ amb els  m√®todes dels trapezis i de Simpson ---amb les funcions \texttt{trapezoid} i \texttt{simpson} del m√≤dul \texttt{scipy.integrate}--- tamb√© es fa servir la funci√≥  d'integraci√≥ gen√®rica \texttt{quad} del mateix m√≤dul,  la qual usa l'equaci√≥ de la funci√≥ que es vol integrar, i torna la integral i una estimaci√≥ de l'error. At√®s que la funci√≥ a integrar t√© una primitiva coneguda, utilitzarem tamb√© la funci√≥ \texttt{integrate} del m√≤dul de matem√†tica simb√≤lica \texttt{sympy} per calcular la integral de forma exacta.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}
\lstinputlisting[caption={Python --- Exemple \ref*{ex:IntegracioNum} \IntegracioNum},label=lst:IntegracioNum]{Python/Exemple-E-3.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}
Integral (trapezoid) = 0.6956
Integral (simpson) = 0.6938
Integral (quad) = 0.6931471805599454, Error = 7.70e-15
Integral (simb√≤lica) = log(2) = 0.693147180559945309417232121458
\end{lstlisting} 

Cal tenir en compte que en la simbologia del m√≤dul \texttt{sympy}, \texttt{log(x)} representa un logaritme neperi√†; un logaritme decimal es representa com \texttt{log(x, 10)}.

Es pot observar que el valor obtingut utilitzant la regla de Simpson no √©s exactament igual al valor obtingut en la resoluci√≥ manual; aquesta difer√®ncia es deu  al fet que en la resoluci√≥ manual s'ha utilitzat de forma conjunta les regles de Simpson 3/8 i 1/3, mentre que la funci√≥ \texttt{simpson}  utilitza de forma conjunta la regla de Simpson i la dels trapezis quan el nombre de punts √©s parell; no obstant aix√≤, la funci√≥ \texttt{simpson} t√© l'avantatge de poder treballar amb divisions d'amplada diferent. L'estimaci√≥ de l'error de la funci√≥ \texttt{quad} √©s prou bona, nom√©s cal comparar el valor obtingut de la integral  amb el valor exacte amb 30 decimals.


\hypertarget{exemple:SolFunNoLin}{\subsection{Exemple \ref*{ex:SolFunNoLin} \SolFunNoLin}}
En el llistat \vref{lst:SolFunNoLin} es pot veure el programa utilitzat per resoldre l'exemple \vref{ex:SolFunNoLin}. Primer es defineix la funci√≥ $f(x)$ i la seva funci√≥ derivada, i despr√©s es fa servir la funci√≥ \texttt{root\_scalar}  del m√≤dul \texttt{scipy.optimize} per trobar la soluci√≥ de $f(x)=0$, amb els m√®todes de Newton i de la secant. A continuaci√≥ es resol el mateix problema utilitzant el m√≤dul  de matem√†tica simb√≤lica \texttt{sympy} a partir de la funci√≥ \texttt{symbols}, que crea variables simb√≤liques, de la funci√≥ \texttt{diff}, que calcula de forma simb√≤lica la derivada d'una funci√≥, i de la funci√≥  \texttt{lambdify}, que crea funcions num√®riques a partir de funcions simb√≤liques.
\lstset{
	language=Python,
	numbers=left,
	frame=lines,
	morekeywords=[1]{as,None,match,case,with}
}


\lstinputlisting[caption={Python --- Exemple \ref*{ex:SolFunNoLin} \SolFunNoLin},label=lst:SolFunNoLin]{Python/Exemple-E-4.py}

Quan s'executa aquest programa, el resultat que s'obt√© √©s:
\lstset{
	language=,
	numbers=none,
	frame=none
}
\begin{lstlisting}
Resoluci√≥ num√®rica
----------------------------------------------------------------
Newton: x = 0.01742101588983377 , f(x) = -1.0913936421275139e-11
Secant: x = 0.017421015887729187 , f(x) = 1.7249829397769645e-05

Resoluci√≥ simb√≤lica + num√®rica
----------------------------------------------------------------
Newton: x = 0.01742101588983377 , f(x) = -1.0913936421275139e-11
Secant: x = 0.017421015887729187 , f(x) = 1.7249829397769645e-05
\end{lstlisting} 
